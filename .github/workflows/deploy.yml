name: Deploy to AWS

# When to run this workflow
on:
  push:
    branches: [ develop ]  # Deploy to staging when code is pushed to develop
  release:
    types: [ published ]   # Deploy to production when a release is published
  workflow_dispatch:       # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    # Step 1: Get the code
    - name: Checkout code
      uses: actions/checkout@v4
    
    # Step 2: Setup Node.js
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    # Step 3: Install dependencies
    - name: Install dependencies
      run: npm ci
    
    # Step 4: Build the applications
    - name: Build backend
      run: npm run build:backend
    
    - name: Build frontend
      run: npm run build:frontend
    
    # Step 5: Determine environment
    - name: Determine environment
      id: environment
      run: |
        if [[ "${{ github.event_name }}" == "release" ]]; then
          echo "env=production" >> $GITHUB_OUTPUT
          echo "ðŸš€ Deploying to PRODUCTION"
        else
          echo "env=staging" >> $GITHUB_OUTPUT
          echo "ðŸ§ª Deploying to STAGING"
        fi
    
    # Step 6: Setup AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1
    
    # Step 7: Get server IP from Terraform
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
    
    - name: Get server IP
      id: server_ip
      run: |
        cd terraform
        terraform init
        terraform workspace select ${{ steps.environment.outputs.env }} || terraform workspace new ${{ steps.environment.outputs.env }}
        terraform apply -var-file="${{ steps.environment.outputs.env }}.tfvars" -auto-approve
        SERVER_IP=$(terraform output -raw server_ip)
        echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
        echo "ðŸŽ¯ ${{ steps.environment.outputs.env }} Server IP: $SERVER_IP"
    
    # Step 8: Setup SSH
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/cvhere-staging.pem
        chmod 600 ~/.ssh/cvhere-staging.pem
        ssh-keyscan -H ${{ steps.server_ip.outputs.server_ip }} >> ~/.ssh/known_hosts
    
    # Step 9: Deploy to server
    - name: Deploy to server
      run: |
        SERVER_IP="${{ steps.server_ip.outputs.server_ip }}"
        echo "ðŸš€ Deploying to server: $SERVER_IP"
        
        # Copy built files to server
        scp -i ~/.ssh/cvhere-staging.pem -r backend/dist ec2-user@$SERVER_IP:~/backend-dist
        scp -i ~/.ssh/cvhere-staging.pem -r frontend/dist ec2-user@$SERVER_IP:~/frontend-dist
        
        # Start services on server
        ssh -i ~/.ssh/cvhere-staging.pem ec2-user@$SERVER_IP << 'EOF'
          source ~/.nvm/nvm.sh
          
          # Stop any existing services
          pkill -f "node.*server" || true
          pkill -f "serve" || true
          
          # Start backend
          cd ~/backend-dist
          nohup node server.js > ~/backend.log 2>&1 &
          
          # Start frontend (simple HTTP server)
          cd ~/frontend-dist
          nohup npx serve -s . -l 3000 > ~/frontend.log 2>&1 &
          
          echo "âœ… Services started"
        EOF
        
        echo "ðŸŽ‰ Deployment complete!"
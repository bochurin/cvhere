name: Deploy to AWS

# When to run this workflow
on:
  push:
    branches: [ develop ]  # Deploy to staging when code is pushed to develop
  release:
    types: [ published ]   # Deploy to production when a release is published
  workflow_dispatch:       # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    # Step 1: Get the code
    - name: Checkout code
      uses: actions/checkout@v4
    
    # Step 2: Setup Node.js
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    # Step 3: Install dependencies
    - name: Install dependencies
      run: npm ci
    
    # Step 4: Build the applications
    - name: Build backend
      run: npm run build:backend
    
    - name: Build frontend
      run: npm run build:frontend
    
    # Step 5: Determine environment
    - name: Determine environment
      id: environment
      run: |
        if [[ "${{ github.event_name }}" == "release" ]]; then
          echo "env=production" >> $GITHUB_OUTPUT
          echo "üöÄ Deploying to PRODUCTION"
        else
          echo "env=staging" >> $GITHUB_OUTPUT
          echo "üß™ Deploying to STAGING"
        fi
    
    # Step 6: Setup AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1
    
    # Step 7: Get server IP from Terraform
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
    
    - name: Get server IP
      id: server_ip
      run: |
        cd terraform
        terraform init
        terraform workspace new ${{ steps.environment.outputs.env }} 2>/dev/null || terraform workspace select ${{ steps.environment.outputs.env }}
        terraform apply -var-file="${{ steps.environment.outputs.env }}.tfvars" -auto-approve
        SERVER_IP=$(terraform output -raw server_ip)
        echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
        echo "üéØ ${{ steps.environment.outputs.env }} Server IP: $SERVER_IP"
        
        # Wait for EC2 instance to be running
        echo "‚è≥ Waiting for EC2 instance to be running..."
        aws ec2 wait instance-running --instance-ids $(terraform output -raw instance_id)
        echo "‚úÖ EC2 instance is running"
    
    # Step 8: Setup SSH
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/cvhere-staging.pem
        chmod 600 ~/.ssh/cvhere-staging.pem
        
        # Verify SSH key was written
        if [ ! -s ~/.ssh/cvhere-staging.pem ]; then
          echo "‚ùå SSH private key is empty or missing from secrets"
          echo "Please add SSH_PRIVATE_KEY to GitHub repository secrets"
          exit 1
        fi
        
        # Wait for EC2 instance to be ready and SSH accessible
        echo "‚è≥ Waiting for SSH to be ready on ${{ steps.server_ip.outputs.server_ip }}..."
        for i in {1..30}; do
          if ssh-keyscan -H ${{ steps.server_ip.outputs.server_ip }} 2>/dev/null | grep -q "ssh-"; then
            echo "Attempt $i/30: SSH is ready, getting host key..."
            ssh-keyscan -H ${{ steps.server_ip.outputs.server_ip }} >> ~/.ssh/known_hosts
            break
          fi
          echo "Attempt $i/30: SSH not ready yet, waiting 10 seconds..."
          sleep 10
        done
        
        # Verify we got the host key (check if known_hosts has content)
        if [ ! -s ~/.ssh/known_hosts ]; then
          echo "‚ùå Failed to get SSH host key after 5 minutes"
          echo "Debug: known_hosts file is empty or missing"
          exit 1
        fi
        
        echo "‚úÖ SSH host key added successfully"
    
    # Step 9: Deploy to server
    - name: Deploy to server
      run: |
        SERVER_IP="${{ steps.server_ip.outputs.server_ip }}"
        echo "üöÄ Deploying to server: $SERVER_IP"
        
        # Copy built files to server
        scp -i ~/.ssh/cvhere-staging.pem -r backend/dist ec2-user@$SERVER_IP:~/backend-dist
        scp -i ~/.ssh/cvhere-staging.pem -r frontend/dist ec2-user@$SERVER_IP:~/frontend-dist
        
        # Start services on server
        ssh -i ~/.ssh/cvhere-staging.pem ec2-user@$SERVER_IP << 'EOF'
          source ~/.nvm/nvm.sh
          
          # Stop any existing services
          pkill -f "node.*server" || true
          pkill -f "serve" || true
          
          # Start backend
          cd ~/backend-dist
          nohup node server.js > ~/backend.log 2>&1 &
          
          # Start frontend (simple HTTP server)
          cd ~/frontend-dist
          nohup npx serve -s . -l 3000 > ~/frontend.log 2>&1 &
          
          echo "‚úÖ Services started"
        EOF
        
        echo "üéâ Deployment complete!"